---
Test
---
!*> Setup
!include .CWS.Setup
!define REST_ROOT {[ http(s)://HOST:PORT/ROOT ]}

*!

!anchor content
!1 !-<img src="files/javadog.png"> API - Application Programming Interface -!
The CWS API consists of 2 main parts, the first is the management part, which
is used to control a CWS instance, and the second is the sharing part. The full
documentation of the API can be found [[here][https://javadog.io/apidocs/]]

There is both a SOAP & REST based !-WebService-! available, the default for
the !-FitNesse-! tests is the SOAP, since it works with both [[!-WildFly-!][https://wildfly.org/]]
and [[Payara][https://payara.fish/]], the json based REST !-WebService-! seems
to have problems under Payara.

Note; CWS is not a HTTP(S) Server, it is an Application, the REST requests will
therefore always return the standard HTTP code 200, whenever an incoming request
has been answered by the CWS. A different !-ReturnCode-! & !-ReturnMessage-! is
set in the response, which will provide more details if the request could not
be processed correctly. The CWS !-ReturnCodes-! is similar to the HTTP codes,
so understanding them should be easier, but the !-ReturnMessage-! is containing
significantly more details regarding the problem. This was decided to ensure
that a System using CWS can better deal with the problems without having to
resort to CWS logs.

[[Management has the following elements: ][#management]]

 * '''[[ Version ][#version]] '''
 * '''[[ !-MasterKey-! ][#masterkey]] '''
 * '''[[ Settings ][#settings]] '''
 * '''[[ Sanitized ][#sanitized]] '''
 * '''[[ Authenticated ][#authenticated]] '''
 * '''[[ Members ][#members]] '''
 * '''[[ Circles of Trust ][#circles]] '''
 * '''[[ Trustees ][#trustees]] '''

[[ Sharing has the following elements: ][#sharing]]

 * '''[[ Data Type ][#datatype]] '''
 * '''[[ Data ][#data]] '''
 * '''[[ !-Signatures-! ][#signatures]] '''

----
[[ Top ][#content]]
!anchor management
!2 Management
Management primarily contain the functionality which is used to control
the system, including altering settings. Adding a system specific !-MasterKey-!
as well as creating Members, Circles of Trust and assign Members as Trustees to
the Circles.

'''Important'''; ''The very first request made with the '''admin''' account will
also set the password for the administrator. By default, the passphrase is empty
or undefined. Which means that it can be set to anything the administrator
prefers, thus preventing that someone forgets to change the default. It is
recommended that common best practices regarding the pick of the passphrase is
followed - for the sake of this test, it is set to 'admin'.''

!* Version
[[ Top ][#content]]
!anchor version
!4 '''Version'''
Returns the current Version of the running CWS instance. This method serves
mainly as a simply way to check if the system is operational. This request is
the only CWS request not requiring any credentials to invoke.

 * Version - Read version of running instance, act as ping
   * SOAP: version
   * REST (POST) request is: ${REST_ROOT}/api/version

|version                                  |
|return code?|return message?|cws version?|
|${SUCCESS}  |Ok             |1.1-SNAPSHOT       |
*!

!* !-MasterKey-!
[[ Top ][#content]]
!anchor masterkey
!4 '''!-MasterKey-!'''
The !-MasterKey-!, is a special System Key, which is not stored anywhere. It is
being created at startup and lives only in the memory of the system until shut
down. The !-MasterKey-! is used for multiple internal things, such as extra key
to unlock accounts. It is therefore not possible to update the !-MasterKey-!,
once the system is being used, since it would essentually convert the CWS
database to a brick, since all keys becomes invalid.

There are 2 ways to set the !-MasterKey-! to something else than the default,
either by using the !-MasterKey WebService-! request or by setting a URL, from
which the raw data to build the key from can be read. To prevent any problems,
in the following, the !-MasterKey-! is reverted to the original, to ensure that
the next test run will also work.

 * !-MasterKey-! - Unlock & Set !-MasterKey-!
   * Only '''System Administrators''' may perform this
   * SOAP: masterKey
   * REST (POST) request is: ${REST_ROOT}/api/masterKey

|master key                                                                                              |
|account name|credential|url                                 |secret|return code?|return message?        |
|admin       |admin     |null                                |admin |${SUCCESS}  |!-MasterKey-! unlocked.|
|admin       |admin     |!-https://javadog.io/img/cloud.png-!|null  |${SUCCESS}  |!-MasterKey-! updated. |
|admin       |admin     |null                                |master|${SUCCESS}  |!-MasterKey-! updated. |
|admin       |admin     |null                                |admin |${SUCCESS}  |!-MasterKey-! updated. |

It should be noted, that unlocking can always be done, but changing the !-MasterKey-! cannot be done once member accounts exists, since
it is not possible for an administrator to update the member keys.

!*> Create Test accounts
|process member                                                                                                                                         |
|account name|credential|credential type|action|member id|public key|new account name|new credential|member role|member id?|return code?|return message?|
|admin       |admin     |PASSPHRASE     |CREATE|null     |null      |user1           |password1     |STANDARD   |user1_id  |${SUCCESS}  |Ok             |
|admin       |admin     |PASSPHRASE     |CREATE|null     |null      |user2           |password2     |STANDARD   |user2_id  |${SUCCESS}  |Ok             |
|admin       |admin     |PASSPHRASE     |CREATE|null     |null      |user3           |password3     |STANDARD   |user3_id  |${SUCCESS}  |Ok             |

*!

|master key                                                                                                                  |
|account name|credential|url |secret    |return code?             |return message?                                           |
|user1       |password1 |null|new secret|${AUTHENTICATION_WARNING}|Given Account is not permitted to perform this request.   |
|admin       |admin     |null|master    |${ILLEGAL_ACTION}        |Cannot alter the !-MasterKey-!, as Member Accounts exists.|
*!

!* Settings
[[ Top ][#content]]
!anchor settings
!4 '''Settings'''
The !-CWS-! Settings request can only be performed by the System
Administrator, i.e. the system super user. It is a way to both extract the
current settings, and update existing values.

 * Settings - Read & Update Settings
   * Only '''System Administrators''' may perform this
   * SOAP: settings
   * REST (POST) request is: ${REST_ROOT}/api/settings

|script|Settings     |admin                          |admin                                                     |
|check |value for key|cws.crypto.symmetric.algorithm |AES_CBC_256                                               |
|check |value for key|cws.crypto.asymmetric.algorithm|RSA_2048                                                  |
|check |value for key|cws.crypto.signature.algorithm |SHA_512                                                   |
|check |value for key|cws.crypto.pbe.algorithm       |PBE_256                                                   |
|check |value for key|cws.crypto.hash.algorithm      |SHA_512                                                   |
|check |value for key|cws.system.salt                |Default salt, also used as kill switch. Must be set in DB.|
|check |value for key|cws.system.locale              |EN                                                        |
|check |value for key|cws.system.charset             |UTF-8                                                     |
|check |value for key|cws.show.all.circles           |true                                                      |
|check |value for key|cws.show.trustees              |true                                                      |
|check |value for key|cws.sanity.check.startup       |true                                                      |
|check |value for key|cws.sanity.check.interval.days |180                                                       |

Note, that if a different user attempts to invoke this request, it will result
in a list of undefined values.

|script|Settings     |user1                          |password1|
|check |value for key|cws.crypto.symmetric.algorithm |undefined|
|check |value for key|cws.crypto.asymmetric.algorithm|undefined|
|check |value for key|cws.crypto.signature.algorithm |undefined|
|check |value for key|cws.crypto.pbe.algorithm       |undefined|
|check |value for key|cws.crypto.hash.algorithm      |undefined|
|check |value for key|cws.system.salt                |undefined|
|check |value for key|cws.system.locale              |undefined|
|check |value for key|cws.system.charset             |undefined|
|check |value for key|cws.show.all.circles           |undefined|
|check |value for key|cws.show.trustees              |undefined|
|check |value for key|cws.sanity.check.startup       |undefined|
|check |value for key|cws.sanity.check.interval.days |undefined|

!5 Symmetric Algorithm
The primary part of all internal encryption is performed using Symmetric Keys. These are all based on the AES algorithms and only the
size of the keys may be changed. The default value is '''AES256''', but if an earlier version of Java 8 is used, or if there is various
problems with allowing this Key size, then it can be set to a lower value. It should be noted, that AES encryption using CBC is considered
''old fashioned'', so it is recommendable to change the algorithm to GCM, even if the maximum bitsize allowed in Java 8 is only 128.
The allowed values are:
 * '''AES_CBC_128'''
 * '''AES_CBC_192'''
 * '''AES_CBC_256'''
 * '''AES_GCM_128'''

|Settings                                                                                                                                                            |
|account name|credential|key                           |value      |return code?      |return message?                                                   |defined?   |
|admin       |admin     |cws.crypto.symmetric.algorithm|AES_GCM_128|${SUCCESS}        |Ok                                                                |AES_GCM_128|
|admin       |admin     |cws.crypto.symmetric.algorithm|AES_CBC_128|${SUCCESS}        |Ok                                                                |AES_CBC_128|
|admin       |admin     |cws.crypto.symmetric.algorithm|AES_CBC_192|${SUCCESS}        |Ok                                                                |AES_CBC_192|
|admin       |admin     |cws.crypto.symmetric.algorithm|AES_CBC_256|${SUCCESS}        |Ok                                                                |AES_CBC_256|
|admin       |admin     |cws.crypto.symmetric.algorithm|AES_CBC_512|${SETTING_WARNING}|Unsupported Crypto Algorithm for 'cws.crypto.symmetric.algorithm'.|AES_CBC_256|

!5 Asymmetric Algorithm
Each Member Account will have a Asymmetric Key generated by default, this is used to encrypt and decrypt the Symmetric Keys, as well as Signing and Verifying signatures.
Higher Key size will give higher security. However, Asymmetric encryption/decryption is very costly compared to Symmetric cryptography. Hence, the use of these Keys is
minimized. The default value is '''RSA2048''', increasing this to a higher Key size, will have a drastic performance cost, and should only be done if a higher level of
security is needed or if enough CWS instances with enough resources is being used, so the cost can be mitigated.
The allowed values are:
 * '''RSA_2048'''
 * '''RSA_4096'''
 * '''RSA_8192'''

|Settings                                                                                                                                                        |
|account name|credential|key                            |value   |return code?      |return message?                                                    |defined?|
|admin       |admin     |cws.crypto.asymmetric.algorithm|RSA_8192|${SUCCESS}        |Ok                                                                 |RSA_8192|
|admin       |admin     |cws.crypto.asymmetric.algorithm|RSA_4096|${SUCCESS}        |Ok                                                                 |RSA_4096|
|admin       |admin     |cws.crypto.asymmetric.algorithm|RSA_2048|${SUCCESS}        |Ok                                                                 |RSA_2048|
|admin       |admin     |cws.crypto.asymmetric.algorithm|RSA_1024|${SETTING_WARNING}|Unsupported Crypto Algorithm for 'cws.crypto.asymmetric.algorithm'.|RSA_2048|

!5 PBE Algorithm
The PBE, Password Based Encryption, Algorithm, which is the Algorithm used to convert a given Passphrase to a Symmetric Key,
is based on the PBKDF2 algorithm, which again is a special way to generated a Symmetric Key, just as normal Symmetric Keys.
The allowed values are:
 * '''PBE_128'''
 * '''PBE_192'''
 * '''PBE_256'''

|Settings                                                                                                                                         |
|account name|credential|key                     |value  |defined?|return code?      |return message?                                             |
|admin       |admin     |cws.crypto.pbe.algorithm|PBE_128|PBE_128 |${SUCCESS}        |Ok                                                          |
|admin       |admin     |cws.crypto.pbe.algorithm|PBE_192|PBE_192 |${SUCCESS}        |Ok                                                          |
|admin       |admin     |cws.crypto.pbe.algorithm|PBE_256|PBE_256 |${SUCCESS}        |Ok                                                          |
|admin       |admin     |cws.crypto.pbe.algorithm|PBE_512|PBE_256 |${SETTING_WARNING}|Unsupported Crypto Algorithm for 'cws.crypto.pbe.algorithm'.|
*!

!* Sanitized
[[ Top ][#content]]
!anchor sanitized
!4 '''Sanitized'''
Any server relies on the storage for correctness. If the storage used has flaws and the stored data is being altered as a consequence of this, then
it may have drastic consequences. Something which is encrypted may be rendered unreadable of just a single bit has been flipped. It is therefore
essential that the storage is always correct. To help with this, CWS has a feature build-in, which runs sanitizing checks at frequent interval,
so all data will be checked at least once every x days, where x is defined as a system property (cws.sanity.check.interval.days).

The sanitizing request is an administrative request, and the result is a list of Data Id's, of the stored Objects where their checksums no longer
match the encrypted data. The check can be made generally or for a Circle of Trust or simply as a check if new errors have occurred since a certain
date.

 * Sanitized - Read current status
   * SOAP: sanitized
   * REST (POST) request is: ${REST_ROOT}/api/sanitized

|sanitized                                                                          |
|account name|credential|circle id|since     |failures?|return code?|return message?|
|admin       |admin     |null     |null      |[]       |${SUCCESS}  |Ok             |
|admin       |admin     |null     |2019-01-01|[]       |${SUCCESS}  |Ok             |
*!

!* Authenticated
[[ Top ][#content]]
!anchor authenticated
!4 '''Authenticated'''
CWS is designed as a backend system to be integrated into other systems, which opens
the question of authentication checks, how to ensure that the standard authentication
checks is aligned with CWS, so CWS can be used to store data securely.

The use-cases for the authentation mechanism is check if an account may access the
securely stored data or not. It is not designed nor intended to replace other
security mechanisms, such as 2FA of existing mechanisms. The check is simply here
to serve the purpose checking if accounts are aligned or not.

This alignment check is required, since the user credentials are needed to unlock
the keys internally. For this reason, the account should use a separate and different
credential to unlock the CWS account, to prevent that poor passwords are passed on to
also weaken the security of the CWS stored data.

 * Authenticated - Check Member Authentication
   * SOAP: authenticated
   * REST (POST) request is: ${REST_ROOT}/api/authenticated

|authenticated                                       |
|account name|credential|return code?|return message?|
|admin       |admin     |${SUCCESS}  |Ok             |
*!

!* Members
[[ Top ][#content]]
!anchor members
!4 '''Members'''
Managing Members is a core part of the Management. The following features can be
performed with the current API:

 * Create Member - Creates a new Account with a given password
   * Only '''System Administrators''' may perform this
   * SOAP: processMember with Action "CREATE"
   * REST (POST) request is: ${REST_ROOT}/api/members/createMember
 * Invite Member - Creates an invitation, so a Member can update themselves
   * Only '''System Administrators''' may perform this
   * SOAP: processMember with Action "INVITE"
   * REST (POST) request is: ${REST_ROOT}/api/members/inviteMember
 * Login - Simple way to temporarily assign a !-SessionKey-! to an account
   * SOAP: processMember with Action "LOGIN"
   * REST (POST) request is: ${REST_ROOT}/api/members/login
 * Logout - Remove the temporary !-SessionKey-! from accessing the account
   * SOAP: processMember with Action "LOGOUT"
   * REST (POST) request is: ${REST_ROOT}/api/members/logout
 * Alter Member Roles - Allows an Administrator to change a Members permissions
   * Only '''System Administrators''' may perform this
   * SOAP: processMember with Action "ALTER"
   * REST (POST) request is: ${REST_ROOT}/api/members/alterMember
 * Update Member - Allows a member to update their account & credentials
   * SOAP: processMember with Action "UPDATE"
   * REST (POST) request is: ${REST_ROOT}/api/members/updateMember
 * Invalidate Member - Allows a member to invalidate their account, rendering it useless
   * SOAP: processMember with Action "INVALIDATE"
   * REST (POST) request is: ${REST_ROOT}/api/members/invalidate
 * Delete Member - Removes a Member Account from the System permanently
   * SOAP: processMember with Action "DELETE"
   * REST (POST) request is: ${REST_ROOT}/api/members/deleteMember
 * Fetch Members - Retrieve a list of one or more Members
   * SOAP: fetchMembers
   * REST (POST) requst is: ${REST_ROOT}/api/members/fetchMembers

Firstly, there are 2 ways to create accounts, both require system administrative
permissions. The first way is to run the CREATE action the second is to use the
INVITE action. The CREATE action requires that the new account is completely defined,
i.e. that the account name and credentials. The INVITE will just require the account
name and issue a signature that the new user can use to unlock the account.

Once accounts are in usage, it may not be feasible to constantly provide both the
account name and credentials. Hence, it is possible to perform a LOGIN. This will
take an Account and an existing Session and link them together for a brief period of
time, how brief is defined via the settings. The session is then the only information
required to identify and unlock the account. Since the Session is thus used as both
an identification and authentication value, it must be guarded well. The Account should
by the end of a session invoke the LOGOUT.

It should be noted, that it is not possible to change the credentials for an Account
using the Session!

|process member                                                                                                                                                                                                                                                        |
|account name|credential       |credential type|action    |member id |public key|new account name|new credential|member role|member id?|signature?       |return code?             |return message?                                                                    |
|admin       |admin            |PASSPHRASE     |CREATE    |null      |null      |admin2          |password2     |ADMIN      |admin2_id |null             |${SUCCESS}               |Ok                                                                                 |
|admin       |admin            |PASSPHRASE     |CREATE    |null      |null      |member1         |password1     |STANDARD   |member1_id|null             |${SUCCESS}               |Ok                                                                                 |
|member1     |password1        |null           |UPDATE    |null      |null      |null            |null          |null       |null      |null             |${SUCCESS}               |Ok                                                                                 |
|member1     |password1        |null           |LOGIN     |null      |null      |null            |session_key   |null       |null      |null             |${SUCCESS}               |Ok                                                                                 |
|null        |session_key      |null           |UPDATE    |null      |null      |null            |new_session   |null       |null      |null             |${VERIFICATION_WARNING}  |It is only permitted to update the credentials when authenticating with Passphrase.|
|null        |session_key      |SESSION        |LOGIN     |null      |null      |null            |new_session   |null       |null      |null             |${SUCCESS}               |Ok                                                                                 |
|null        |new_session      |SESSION        |LOGIN     |null      |null      |null            |new_session   |null       |null      |null             |${SUCCESS}               |Ok                                                                                 |
|null        |new_session      |SESSION        |CREATE    |null      |null      |user9           |password9     |null       |null      |null             |${AUTHORIZATION_WARNING} |Members are not permitted to create new Accounts.                                  |
|member1     |password1        |PASSPHRASE     |INVALIDATE|null      |null      |null            |null          |null       |null      |null             |${SUCCESS}               |Account has been Invalidated.                                                      |
|member1     |password1        |null           |UPDATE    |null      |null      |null            |null          |null       |null      |null             |${AUTHENTICATION_WARNING}|Cannot authenticate the Account from the given Credentials.                        |
|null        |new_session      |SESSION        |UPDATE    |null      |null      |null            |null          |null       |null      |null             |${AUTHENTICATION_WARNING}|No Session could be found.                                                         |
|admin       |admin            |null           |DELETE    |member1_id|null      |null            |null          |null       |null      |null             |${SUCCESS}               |The Member 'member1' has successfully been deleted.                                |
|admin       |admin            |null           |INVITE    |null      |null      |invitee         |null          |null       |invitee_id|invitee_signature|${SUCCESS}               |Ok                                                                                 |
|invitee     |invitee_signature|SIGNATURE      |UPDATE    |null      |null      |invitee         |invitee       |null       |invitee_id|null             |${SUCCESS}               |Ok                                                                                 |
|admin       |admin            |PASSPHRASE     |DELETE    |invitee_id|null      |null            |null          |null       |null      |null             |${SUCCESS}               |The Member 'invitee' has successfully been deleted.                                |

|fetch members                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|account name|credential|member id|members?                                                                                                                                                                                                                                                                                                                                                                                                                                                           |circles?|return code?|return message?|
|admin       |admin     |null     |[Member{memberId='admin_id', accountName='admin', memberRole='ADMIN', publicKey='null'}, Member{memberId='admin2_id', accountName='admin2', memberRole='ADMIN', publicKey='null'}, Member{memberId='user1_id', accountName='user1', memberRole='STANDARD', publicKey='null'}, Member{memberId='user2_id', accountName='user2', memberRole='STANDARD', publicKey='null'}, Member{memberId='user3_id', accountName='user3', memberRole='STANDARD', publicKey='null'}]|[]      |${SUCCESS}  |Ok             |
|user2       |password2 |user1_id |[Member{memberId='user1_id', accountName='user1', memberRole='STANDARD', publicKey='null'}]                                                                                                                                                                                                                                                                                                                                                                        |[]      |${SUCCESS}  |Ok             |
*!

!* Circles of Trust
[[ Top ][#content]]
!anchor circles
!4 '''Circles of Trust'''
Circles of Trust is a core part of CWS, as this is the grouping of Members or
''Trustees'', to facilitte sharing of information. There are no limits as to
who may create a Circle of Trust. Circles of Trust do not have an Owner, but
rather one or more Circle Administrators. The first Member to create a Circle
will automatically become the initial Circle Administrator - or if a Member Id
is given, then this Member will be the initial Circle Administrator.

Circles of Trust do not have much information initially - basically just their
name, which must be unique. Circles of Trust may also have an external Circle
Key, which means a shared Key that can be used by Trustees from a Client system.

 * Create Circle - Creates a new Circle of Trust in CWS
   * SOAP: processCircle with Action "CREATE"
   * REST (POST) request is: ${REST_ROOT}/api/circles/createCircle
 * Update Circle - Allows the Circle of Trust to be renamed
   * SOAP: processCircle with Action "UPDATE"
   * REST (POST) request is: ${REST_ROOT}/api/circles/updateCircle
 * Delete Circle - Removes a Circle with all Trustees & Data from the System
   * SOAP: processCircle with Action "DELETE"
   * REST (POST) request is: ${REST_ROOT}/api/circles/deleteCircle
 * Fetch Circles - Retrieves a list of Circles in the current CWS instance
   * SOAP: fetchCircles
   * REST (POST) request is: ${REST_ROOT}/api/circles/fetchCircles

|process circle                                                                                                                                                            |
|account name|credential|action|circle id |circle name    |member id|circle key      |circle id?|return code?             |return message ?                                |
|admin       |admin     |CREATE|null      |circle1        |user1_id |null            |circle1_id|${SUCCESS}               |Ok                                              |
|user1       |password1 |CREATE|null      |circle1        |null     |null            |null      |${IDENTIFICATION_WARNING}|A Circle with the requested name already exists.|
|user1       |password1 |CREATE|null      |circle2        |null     |null            |circle2_id|${SUCCESS}               |Ok                                              |
|user2       |password2 |CREATE|null      |circle3        |null     |super secret key|circle3_id|${SUCCESS}               |Ok                                              |
|user2       |password2 |CREATE|null      |circle5        |null     |null            |circle5_id|${SUCCESS}               |Ok                                              |
|user2       |password2 |UPDATE|circle5_id|new Circle Name|null     |null            |null      |${SUCCESS}               |Ok                                              |
|user2       |password2 |DELETE|circle5_id|null           |null     |null            |null      |${SUCCESS}               |Ok                                              |


The Fetch Circles request is intended to get a listing of all the current Circles in CWS, note that only if a user is Member of a Circle,
can they retrieve the Circle Key.

|fetch circles                                                                                                                                                                                                                                                                         |
|account name|credential|circles?                                                                                                                                                                                                                         |return code?|return message?|
|user1       |password1 |[Circle{circleId='circle1_id', circleName='circle1', circleKey='null'}, Circle{circleId='circle2_id', circleName='circle2', circleKey='null'}, Circle{circleId='circle3_id', circleName='circle3', circleKey='null'}]            |${SUCCESS}  |Ok             |
|user2       |password2 |[Circle{circleId='circle1_id', circleName='circle1', circleKey='null'}, Circle{circleId='circle2_id', circleName='circle2', circleKey='null'}, Circle{circleId='circle3_id', circleName='circle3', circleKey='super secret key'}]|${SUCCESS}  |Ok             |
*!

!* Trustees
[[ Top ][#content]]
!anchor trustees
!4 '''Trustees'''
The !-CWS-! Create Circle request can be performed by all standard accounts.

 * Add Trustee
   * SOAP: processTrustee with Action "ADD"
   * REST (POST) request is: ${REST_ROOT}/api/trustees/addTrustee
 * Alter Trustee
   * SOAP: processTrustee with Action "ALTER"
   * REST (POST) request is: ${REST_ROOT}/api/trustees/alterTrustee
 * Remove Trustee
   * SOAP: processTrustee with Action "REMOVE"
   * REST (POST) request is: ${REST_ROOT}/api/trustees/removeTrustee
 * Fetch Trustees
   * SOAP: fetchTrustees
   * REST (POST) request is: ${REST_ROOT}/api/trustees/fetchTrustees

|process trustee                                                                              |
|account name|credential|action|circle id |member id|trust level|return code?|return message ?|
|user1       |password1 |ADD   |circle2_id|user2_id |WRITE      |${SUCCESS}  |Ok              |
|user1       |password1 |ADD   |circle2_id|user3_id |READ       |${SUCCESS}  |Ok              |
|user2       |password2 |ADD   |circle3_id|user1_id |WRITE      |${SUCCESS}  |Ok              |
|user1       |password1 |ALTER |circle2_id|user3_id |ADMIN      |${SUCCESS}  |Ok              |
|user1       |password1 |ALTER |circle2_id|user3_id |READ       |${SUCCESS}  |Ok              |

If a Fetch Members for a given User is invoked now, then the list of Circles which the Member is entrusted with will also be returned.

|fetch members                                                                                                                                                                                                                     |
|account name|credential|member id|members?                                                                                   |circles?                                                               |return code?|return message?|
|user2       |password2 |user3_id |[Member{memberId='user3_id', accountName='user3', memberRole='STANDARD', publicKey='null'}]|[Circle{circleId='circle2_id', circleName='circle2', circleKey='null'}]|${SUCCESS}  |Ok             |

However, the Fetch Members request with the Circle listing is pruned, and instead the fetch Trustees should be used, as it will
return a more accurate depiction of the relations. Note, that this request is more stringent in the results returned. System
Administrators are allowed to retrieve most information but members are only allowed to retrieve information if a relation between
the Member & Circle already exists.

|fetch trustees                                                                                                                                                                                                                                                                                                                                                                                |
|account name|credential|circle id |trustees?                                                                                                                                                                                                                                                       |return code?             |return message?                                                 |
|admin       |admin     |circle3_id|[Trustee{memberId='user1_idaccountName='user1', circleId='circle3_id', circleName='null', trustLevel='WRITE', publicKey='null'}, Trustee{memberId='user2_idaccountName='user2', circleId='circle3_id', circleName='null', trustLevel='ADMIN', publicKey='null'}]|${SUCCESS}               |Ok                                                              |
|user1       |password1 |circle3_id|[Trustee{memberId='user1_idaccountName='user1', circleId='circle3_id', circleName='null', trustLevel='WRITE', publicKey='null'}, Trustee{memberId='user2_idaccountName='user2', circleId='circle3_id', circleName='null', trustLevel='ADMIN', publicKey='null'}]|${SUCCESS}               |Ok                                                              |
|user2       |password2 |circle3_id|[Trustee{memberId='user1_idaccountName='user1', circleId='circle3_id', circleName='null', trustLevel='WRITE', publicKey='null'}, Trustee{memberId='user2_idaccountName='user2', circleId='circle3_id', circleName='null', trustLevel='ADMIN', publicKey='null'}]|${SUCCESS}               |Ok                                                              |
|user3       |password3 |circle3_id|[]                                                                                                                                                                                                                                                              |${IDENTIFICATION_WARNING}|=~/No Trustee information found for member 'user3' and circle.*/|
*!

----
[[ Top ][#content]]
!anchor sharing
!2 Sharing

!* !-DataType-!
!anchor datatype
!4 '''Data Type'''
Since all data is stored in CWS encrypted, and CWS only cares that the bytes which
came in, also goes out - it can be hard for an application or server using CWS to
ascertain what is behind the bytes. For this reason, CWS supports storing data with
a "data type".

Data Types can be anything; by default 2 types exist: "folder" and "data". If nothing
is explicitly defined, the "data" will always be picked. The "folder" is simple there
to provide the possibility to have structures of data, and it has the unique feature
that Data Objects can have a folder as parent. All Circles of Trust will have a standard
folder as their root, and it is used transparently within CWS.

Working with data types requires administrative permissions, the request must be made
as either system administrator or circle administrator. In the example below, admin is
a system administrator, user1 is a circle administrator and user2 is neither.

!-<img src="files/note.png" align="left">-! Contrary to all other entities in CWS, data types do not have any id's, they
only have a name and a custom definition. It is only allow

There are 3 kinds of actions / requests which can be made for data Types
 * Process !-DataType-!
   * SOAP: processDataType with Action "PROCESS"
   * REST (POST) request is: ${REST_ROOT}/api/dataTypes/processDataType
 * Delete !-DataType-!
   * SOAP: processDataType with Action "DELETE"
   * REST (POST) request is: ${REST_ROOT}/api/dataTypes/deleteDataType
 * Fetch !-DataTypes-!
   * SOAP: fetchDataTypes
   * REST (POST) request is: ${REST_ROOT}/api/dataTypes/fetchDataTypes

|process dataType                                                                                                                                                   |
|account name|credential|action |name          |type                         |return code?            |return message?                                              |
|admin       |admin     |PROCESS|MIMEType PDF  |application/pdf              |${SUCCESS}              |Ok                                                           |
|user1       |password1 |PROCESS|jsonObject    |{"a":"b","c":"d"}            |${SUCCESS}              |Ok                                                           |
|admin       |admin     |PROCESS|Object42      |com.company.object.ObjectName|${SUCCESS}              |Ok                                                           |
|user3       |password3 |PROCESS|Awesome Object|Cool                         |${AUTHORIZATION_WARNING}|The requesting Account is not permitted to Process Data Type.|
|user3       |password3 |DELETE |MIMEType PDF  |                             |${AUTHORIZATION_WARNING}|The requesting Account is not permitted to Process Data Type.|
|admin       |admin     |DELETE |MIMEType PDF  |null                         |${SUCCESS}              |Ok                                                           |

|fetch dataTypes                                                                                                                                                                                                                                                                     |
|account name|credential|data types?                                                                                                                                                                                                                    |return code?|return message?|
|admin       |admin     |!-[DataType{typeName='folder', type='Folder'}, DataType{typeName='data', type='Data Object'}, DataType{typeName='jsonObject', type='{"a":"b","c":"d"}'}, DataType{typeName='Object42', type='com.company.object.ObjectName'}]-!|${SUCCESS}  |Ok             |
*!

!* Data
[[ Top ][#content]]
!anchor data
!4 '''Data'''

 * Add Data to a Circle of Trust
   * SOAP: processData with Action "ADD"
   * REST (POST) request is: ${REST_ROOT}/api/data/addData
 * Copy Data from one Circle of Trust to another
   * SOAP: processData with Action "COPY"
   * REST (POST) request is: ${REST_ROOT}/api/data/copyData
 * Move Data from one Circle of Trust to another
   * SOAP: processData with Action "MOVE"
   * REST (POST) request is: ${REST_ROOT}/api/data/moveData
 * Update Data record in a Circle of Trust
   * SOAP: processData with Action "UPDATE"
   * REST (POST) request is: ${REST_ROOT}/api/data/updateData
 * Delete Data record from a Circle of Trust
   * SOAP: processData with Action "DELETE"
   * REST (POST) request is: ${REST_ROOT}/api/data/deleteData
 * Fetch Data from a Circle of Trust
   * SOAP: fetchData
   * REST (POST) request is: ${REST_ROOT}/api/data/fetchData

|process data                                                                                                                                                                                               |
|account name|credential|action|circle id |data id  |data name|type name     |target folder id|target circle id|data               |return code?        |return message?                                    |
|user1       |password1 |ADD   |circle1_id|null     |data1    |folder        |null            |null            |null               |${SUCCESS}          |Ok                                                 |
|user1       |password1 |ADD   |circle1_id|null     |data2    |data          |null            |null            |First Data Object  |${SUCCESS}          |Ok                                                 |
|user1       |password1 |ADD   |circle2_id|null     |data3    |Awesome Object|null            |null            |Second Data Object |${INTEGRITY_WARNING}|Cannot find a matching !-DataType-! for the Object.|
|user1       |password1 |DELETE|null      |data1_id |null     |null          |null            |null            |null               |${SUCCESS}          |Ok                                                 |
|user1       |password1 |ADD   |circle1_id|null     |data4    |data          |null            |null            |Another Data Object|${SUCCESS}          |Ok                                                 |
|user1       |password1 |ADD   |circle1_id|null     |data5    |data          |null            |null            |More Data          |${SUCCESS}          |Ok                                                 |
|user1       |password1 |ADD   |circle2_id|null     |status   |null          |null            |null            |initial            |${SUCCESS}          |Ok                                                 |
|user1       |password1 |UPDATE|circle2_id|status_id|null     |null          |null            |null            |updated content    |${SUCCESS}          |Ok                                                 |
|user1       |password1 |ADD   |circle2_id|null     |data6    |null          |null            |null            |some more data     |${SUCCESS}          |Ok                                                 |
|user1       |password1 |COPY  |circle2_id|data6_id |copied   |null          |null            |circle1_id      |null               |${SUCCESS}          |Ok                                                 |
|user1       |password1 |MOVE  |circle2_id|data6_id |moved    |null          |null            |circle1_id      |null               |${SUCCESS}          |Ok                                                 |
|user1       |password1 |UPDATE|circle1_id|copied_id|copied   |null          |null            |null            |null               |${SUCCESS}          |Ok                                                 |
|user1       |password1 |UPDATE|circle1_id|moved_id |moved    |null          |null            |null            |null               |${SUCCESS}          |Ok                                                 |

|fetch data                                                                                                                                                                                   |
|account name|credential|circle id |data id  |page number|page size|records?|folder id?     |data id?             |data name?     |type name?  |data?            |return code?|return message?|
|user1       |password1 |circle1_id|null     |1          |2        |5       |circle1_root_id|[moved_id, copied_id]|[moved, copied]|[data, data]|null             |${SUCCESS}  |Ok             |
|user1       |password1 |circle1_id|null     |2          |2        |5       |circle1_root_id|[data5_id, data4_id] |[data5, data4] |[data, data]|null             |${SUCCESS}  |Ok             |
|user1       |password1 |null      |data2_id |null       |null     |1       |circle1_root_id|data2_id             |data2          |data        |First Data Object|${SUCCESS}  |Ok             |
|user1       |password1 |circle2_id|status_id|null       |null     |1       |circle2_root_id|status_id            |status         |data        |updated content  |${SUCCESS}  |Ok             |
*!

!* Signatures
[[ Top ][#content]]
!anchor signatures
!4 '''Signatures'''

Signing documents means creating cryptographic checksum of the document based on the signing members key. The signature can then be given to others together with the document, to verify that the document has not been tampered with.
CWS supports simply signing of documents, and later verification of same by other members. Neither the document signed, nor the signarure are stored in CWS, only some meta information regarding who signed it and optionally when it expires.

 * Sign Document
   * SOAP: sign
   * REST (POST) request is: ${REST_ROOT}/api/signatures/signDocument
 * Verify Signature
   * SOAP: verify
   * REST (POST) request is: ${REST_ROOT}/api/signatures/verifySignature
 * Fetch Signatures
   * SOAP: fetchSignatures
   * REST (POST) request is: ${REST_ROOT}/api/signatures/fetchSignatures

|sign                                                                                                                    |
|account name|credential|data                                 |expires     |signature?      |return code?|return message?|
|user1       |password1 |Data to be signed, already expired   |${yesterday}|user1_signature1|${SUCCESS}  |Ok             |
|user1       |password1 |Data to be signed, without expiration|null        |user1_signature2|${SUCCESS}  |Ok             |
|user1       |password1 |Data to be signed, expires tomorrow  |${tomorrow} |user1_signature3|${SUCCESS}  |Ok             |

|verify                                                                                                                                  |
|account name|credential|data                                 |signature       |verified?|return code?        |return message?           |
|user2       |password2 |Data to be signed, already expired   |user1_signature1|false    |${SIGNATURE_WARNING}|The Signature has expired.|
|user2       |password2 |Data to be signed, without expiration|user1_signature2|true     |${SUCCESS}          |Ok                        |
|user2       |password2 |Data to be signed, expires tomorrow  |user1_signature3|true     |${SUCCESS}          |Ok                        |
|user2       |password2 |Data to be signed, expires tomorrow  |user1_signature2|false    |${SUCCESS}          |Ok                        |

|fetch signatures                                                                                                                                                                                                                                                                                        |
|account name|credential|signatures?                                                                                                                                                                                                                                        |return code?|return message?|
|user1       |password1 |[Signature{signature='user1_signature3', expires='${tomorrow}', verifications='1'}, Signature{signature='user1_signature2', expires='null', verifications='1'}, Signature{signature='user1_signature1', expires='${yesterday}', verifications='0'}]|${SUCCESS}  |Ok             |
|user2       |password2 |[]                                                                                                                                                                                                                                                 |${SUCCESS}  |Ok             |

*!
